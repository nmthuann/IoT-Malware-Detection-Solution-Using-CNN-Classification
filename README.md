# IoT-Malware-Detection-Solution-Using-CNN-Classification

# Introduction

Đây là Lab 2 trong môn IoT do thầy Minh Lịnh giảng dạy tại Học Viện Bưu Chính Viễn Thông tại TP.HCM. Bài Lab tập trung vào việc tìm hiểu và khám phá mô hình Deep Learning - CNN (Mạng Nơ-ron Tích chập). Model CNN được xây dựng theo mô hình AlexNet (2012).

> Note: Mục tiêu của bài lab là giúp sinh viên nắm bắt các khái niệm cơ bản và ứng dụng của mô hình CNN thông qua việc phân tích và khám phá kiến trúc của AlexNet. Sinh viên sẽ được hướng dẫn về cách xây dựng, huấn luyện và đánh giá mô hình để hiểu rõ hơn về cách hoạt động của mạng CNN trong việc xử lý hình ảnh

# Requirement

- Ngôn ngữ lập trình: **python 3.10**, + Visual studio code, pycharm, thony, ...
- Thư viện sử dụng gồm có: tensorflow, requirements, numpy, ...
- Hệ điều hành: Window Server, Linux (Ubuntu), Windown 10Pro.
- Microsoft Software Removal Tool, Binvis.
- Tìm hiểu: Machine Learning/Deep Learning, IoT/ IioT, AI.
- chuyển đổi từ **CPU** sang **GPU** nếu có thể để tăng tốc độ tính toán và xử lý hình ảnh.

# Folder Stucture

- `data/`: Chứa 2 file nén .zip begin và malware.
- `train.py`: file train.
- `docs/images`: Chứa ảnh.
- `script.py`: file script.
- `entropy.py`: File tính entroypy.
- `README.md`: File này.

# Table of contents

- [**ABSTRACT**](#abstract)
- [**THEORY**](#theory)
  - [**Types of Neural Networks**](#type-of-neural-networks)
  - [**Understanding CNN**](#understanding-CNN)
  - [**Structure CNN**](#structure-CNN)
  - [**Introduction TENSORFLOW lib**](#tensorflow-lib)
  - [**Build Model**](#build-model)
- [**METHODOLOGY**](#methodology)
- [**DATASET**](#dataset)
  - [**Introduce dataset**](#introduce-dataset)
  - [**Exploring and Analyzing the Dataset**](#exploring-analyzing-dataset)
  - [**Data Preprocessing**](#data-preprocessing)
  - [**Feature Extraction**](#feature-extraction)
- [**MODEL MACHINE LEARNING**](#model-machine-learning)
  - [**Build Model**](#build-model)
  - [**CNN Models Popular**](#cnn-models-popular)
  - [**Choose Model and Params for Model**](#choose-model-params)
- [**EVALUATION AND RESULT**](#evaluation-result)
- [**CONCLUSION**](#conslution)
- [**REFERENCE**](#reference)

## [**ABSTRACT**](#abstract)

Internet of Things (IoT) là một thuật ngữ dùng để chỉ tập hợp các thiết bị kết nối internet rộng rãi, chia sẻ dữ liệu tự động và theo yêu cầu qua mạng mà chúng kết nối. Các loại thiết bị IoT khác nhau có thể cảm nhận và thu thập dữ liệu từ thế giới vật chất như nhiệt độ, và các thiết bị khác có thể hành động dựa trên dữ liệu này để thực hiện các quá trình thay đổi đặc điểm của thế giới vật chất, chẳng hạn như điều chỉnh nhiệt độ trong phòng. Thiết bị IoT đang tham gia nhiều hơn vào các quá trình quan trọng, đòi hỏi các biện pháp an ninh cao cần được chú ý liên tục để hoạt động đúng. Không thể phủ nhận rằng sự có sẵn của 5G sẽ khiến IoT tham gia nhiều hơn vào các lĩnh vực hàng ngày. IoT được sử dụng trong nhiều ứng dụng hỗ trợ các lĩnh vực như nông nghiệp, lưới điện thông minh, thành phố thông minh, nhà thông minh và phương tiện thông minh. Thường có nhiều loại thiết bị IoT khác nhau tham gia vào các ứng dụng này, mỗi loại từ một nhà sản xuất khác nhau. Các nhà phát triển thường mua số lượng lớn thiết bị IoT từ các nhà sản xuất mà bỏ qua thực tế rằng một số trong số đó được thiết kế mà không tính đến an ninh, điều này có thể gây ra một loạt các vấn đề trong các ứng dụng đã phát triển và mạng mà chúng chạy trên. Lý do chính dẫn đến việc bỏ qua an ninh khi sản xuất những thiết bị này là do thiếu tiêu chuẩn an ninh cho các thiết bị IoT hoặc sự thiếu thực thi nó.

## [**THEORY**](#theory)

### [**Types of Neural Networks**](#type-of-neural-networks)

- CNN (Convolution Neural Network): phương pháp tích chập.
- RNN (Recurrent Neural Network): Phương pháp hồi quy “_tìm hiểu LSTM_”.
- DNN (DNN-Deep neural Network): là một mạng neuron nhân tạo (ANN) với nhiều đơn vị lớp ẩn giữa lớp đầu vào và đầu ra.
- ANN: Mạng thần kinh nhân tạo
- ...

### [**Understanding CNN**](#understanding-CNN)

- Một mạng thần kinh tích chập là một lớp của mạng thần kinh sâu, áp dụng phổ biến nhất để phân tích hình ảnh trực quan.
- Máy tính coi hình ảnh đầu vào là 1 mảng pixel và nó phụ thuộc vào độ phân giải của hình ảnh. Dựa trên độ phân giải hình ảnh, máy tính sẽ thấy H x W x D (H: Chiều cao, W: Chiều rộng, D: Độ dày). Ví dụ: Hình ảnh là mảng ma trận RGB 6x6x3 (3 ở đây là giá trị RGB).
- Thứ tự raw pixel > edges > shapes > facial > high-level features

### [**Structure CNN**](#structure-CNN)

- ![alt text](./docs/images/cnn-model-structure.jpeg)

### [**Introduction TENSORFLOW lib**](#tensorflow-lib)

#### 1. Keras là gì?

Keras là một thư viện open source cho phép xây dựng nhanh chóng một model CNN hoặc RNN, phù hợp với người mới bắt đầu.

#### 2. Kiến trúc của TensorFlow

- **Tiền xử lý dữ liệu**
- **Dựng model**
- **Train và ước tính model**

#### 3. Các thuật ngữ, tham số, và khái niệm trong TensorFlow

##### a. Model.Sequential

Keras cung cấp 2 kiểu xây dựng model là `Sequential` và function API. Bài này sử dụng `Sequential`. `Sequential` là một chồng các lớp đơn giản với một đầu vào và một đầu ra.

1.  Sequential: Sequential là một chồng các lớp đơn giản với 1 đầu vào và 1 đầu ra ⇒ bài này sử dụng Sequential.
2.  Function API
    ![Một model Conv2D cơ bản](https://github.com/nmthuann/IoT-Malware-Detection-Solution-Using-CNN-Classification/blob/main/docs/images/tensorflow-function-api.png?raw=true)
    Một model Conv2D cơ bản

- **Conv2D**

  - `filters`: Số nguyên, chiều của không gian đầu ra (nghĩa là số lượng bộ lọc đầu ra trong tích chập).
  - `kernel_size`: Một số nguyên hoặc danh sách hai số nguyên, chỉ định chiều cao và chiều rộng của kernel.
  - `strides`: Bước nhảy của kernel (bộ lọc).
  - `activation`: Chọn hàm kích hoạt phù hợp với công việc của bạn.
    - _relu_: Hàm luôn dương.
    - _leaky relu_
    - _softmax_: Chuyển đổi một vectơ các giá trị thành phân phối xác suất.
    - _sigmoid_
    - _tanh_
    - _linear_
  - `input_shape`: Hình dạng đầu vào, ví dụ `shape(*size*, height, width, layer)`.
  - `padding`: Thêm các phần tử 0 để làm đệm cách đều nhau ở bên trái/phải hoặc lên/xuống của đầu vào. Khi `padding = "same"` và `strides = 1`, đầu ra có cùng kích thước với đầu vào.
  - **Transposed convolution** hay **deconvolution** có thể coi là phép toán ngược của convolution.

- **Batch normalization**

  - Là một kỹ thuật để đào tạo mạng nơ ron sâu, chuẩn hóa các đầu vào thành một layer cho mỗi mini-batch (Mini-batch gradient descent - Dùng một phần dữ liệu trong training set cho mỗi lần thực hiện bước tính đạo hàm). Điều này có tác dụng ổn định quá trình học tập và giảm đáng kể số lượng epoch đào tạo cần thiết để đào tạo mạng sâu.
  - Mục đích chính của batch normalization đó là chuẩn hóa dữ liệu ở các layer theo batch về phân phối chuẩn để quá trình gradient descent hội tụ nhanh hơn.

- **Max Pooling (MaxPool2D)**
  ⇒ còn có MaxPooling2D, AvergaPooling1D, 2D ( lấy max , trung bình) với từng size.

  - `pool_size`: kích thước ma trận để lấy max hay average
  - `strides`: tương tự
  - `padding`
  - `data_format`

- **Flatten**: là một loại hoạt động reshape cụ thể trong đó tất cả các axes được làm phẳng ( smooshed) hoặc ghép lại (squashed ) với nhau.

- **Dense**
  Layer này cũng như một layer neural network bình thường, với các tham số:
- Units: Số chiều output, như số class sau khi train.
- Activation: Chọn activation đơn giản với sigmoid thì output có 1 class.
- Use_bias: Có sử dụng bias hay không (True or False).
- **Dropout**
  - Kỹ thuật dropout là việc bỏ qua một vài unit trong suốt quá trình train trong mô hình, các unit bị bỏ qua được lựa chọn ngẫu nhiên.
  - Tránh tình trạng overfitting (học vẹt), node nào chưa rõ thì có thể bỏ qua.
  - Hệ số dropout tốt nhất là 0.2 và 0.5.
  - Dropout đòi hỏi phải gấp đôi quá trình huấn luyện để đạt được sự hội tụ, tuy nhiên, thời gian huấn luyện cho mỗi epoch sẽ ít hơn.

##### b. Các phương pháp trong Model

- `Model.summary()`
- `Model.compile()`: ở hàm này chúng ta sử dụng để training models như thuật toán train qua optimizer như Adam, SGD, RMSprop,..
  > Learning_rate : dạng float , tốc độc học, chọn phù hợp để hàm số hội tụ nhanh.
- `Model.fit()`
  - `Epochs`: một epoch được tính khi chúng ta đưa tất cả tập train vào mạng NN. ⇒ Ví dụ, bạn có 10 triệu bức hình trong tập train, bạn cho toàn bộ số hình đó là input của mô hình 3 lần, suy ra bạn đã train được 3 epoch.
  - `Batch Size`: thể hiện số lượng mẫu mà Mini-batch GD sử dụng cho mỗi lần cập nhật trọng số . ⇒ ví dụ: chọn batch size =32, nghĩa là 1 lần lặp ta sẽ cho ngẫu nhiên 32 bức nhìn chó hoặc mèo chạy lan truyền tiến trong mạng neural network. tiếp theo bạn quăng tiếp 32 hình ngẫu nhiên, không lặp với các hình trước đó, vào mạng, quăng đến khi nào không còn hình nào có thể quăng vào nữa -> bạn hoàn thành 1 epoch.
  - `Iteration`: Iterations là số lượng batchs cần để hoàn thành 1 epoch ⇒ ví dụ: có 20.000 tấm hình, có batch size là 500 thì có 40 (iteration lặp cho 1 epoch)
    > Ví dụ: Giả sử ta có tập huấn luyện gồm 55.000 hình ảnh chọn batch-size là 55 images có nghĩa là mỗi lần cập nhật trọng số, ta dùng 55 images. Lúc đó ta mất 55.000/55 = 1000 iterations (số lần lặp) để duyệt qua hết tập huấn luyện (hoàn thành 1 epochs). Có nghĩa là khi dữ liệu quá lớn, chúng ta không thể đưa cả tập data vào train được, ta phải chia nhỏ data ra thành nhiều batch nhỏ hơn.

##### c. Đơn vị (Unit)

Là giá trị của một điểm nằm trên ma trận khối ở mỗi tầng của mạng CNN.

#### Liên quan

1. Tiền xử lý
2. Loss_function:

- mean_squared_error: Thường dùng trong regression tính theo eculid.
- mean_absolute_error: Để tính giá trị tuyệt đối.
- binary_crossentropy: Dùng cho classifier 2 class.
- categorical_crossentropy: Dùng cho classifier nhiều class.

3. Optimizers

- SGD: Stochastic Gradient Descent optimizer.
- RMSprop.
- Adam.

4. Callbacks: Khi models chúng ta lớn khi training thì gặp lỗi ta muốn lưu lại models để chạy lại thì ta sử dụng callbacks.

- ModelsCheckpoint: Lưu lại model sau mỗi epoch.
- EarlyStopping: Stop training khi models training không hiệu quả (Loss không có dấu hiệu giảm).
- ReduceLROnPlateau: Giảm learning mỗi khi metrics không cải thiện.

### [**Build Model**](#build-model)

#### 1. `keras.layers.Conv2D()`

- `filters`: Số lượng bộ lọc.
- `kernel_size`: Kích thước của kernel.

- `strides`: Bước nhảy của kernel.
- `activation`: Hàm kích hoạt.
- `input_shape`: Hình dạng đầu vào.
- `padding`: Đệm (padding).

#### 2. `keras.layers.BatchNormalization()`

- Lớp chuẩn hóa batch.

#### 3. `keras.layers.MaxPool2D()`

- `pool_size`: Kích thước của pool.
- `strides`: Bước nhảy của pool.

#### 4. `keras.layers.Flatten()`

- Lớp làm phẳng (Flatten).

#### 5. `keras.layers.Dense()`

- Lớp Dense.

#### 6. `keras.layers.Dropout()`

- Lớp Dropout.

#### 7. Scaling Model

- [Nghiên cứu về Scaling Model](https://arxiv.org/pdf/1905.11946v5.pdf).

##### - Baseline

##### - Width Scaling

- **Ưu điểm:**
- **Nhược điểm:**

##### - Depth Scaling

##### - Resolution Scaling

##### - Compound Scaling

#### 8. ...

## [**METHODOLOGY**](#methodology)

## [**DATASET**](#dataset)

### [**Introduce dataset**](#introduce-dataset)

- Tập dữ liệu số lượng: 11,273 mẫu mã độc IoT học Malware và 3,697 mẫu lành tính.
- Các mẫu mã độc này được đánh nhãn.

### [**Exploring and Analyzing the Dataset**](#exploring-analyzing-dataset)

| Family Name |      Count |
| ----------- | ---------: |
| Mirai       |      6,793 |
| Gafgyt      |      4,427 |
| Other       |         53 |
| Benign      |      3,697 |
| **Total**   | **14,970** |

> Note: - Tỷ lệ phân chia quá trình training 2 phần: Huấn luyện (80%), tập kiểm thử (20%)

### [**Data Preprocessing**](#data-preprocessing)

- Đưa dữ liệu về dạng hình ảnh
- Tìm hiểu về: Entropy, các giá trị màu của entropy được chia ra làm 5 nhóm:
  • Có trật tự (Ordered)
  • Thấp (Low)
  • Trung bình (Medium)
  • High (Cao)
  • Ngẫu nhiên (Random)

- Tính toán entropy của một tệp nhị phân:
  X = 0, …, 255 đại diện cho một byte.
  Đầu tiên tính toán chuỗi entropy của một chuỗi byte.
  Entropy cho biết mức độ mà dữ liệu bị xáo trộn. (Shannon)
- ![alt text](./docs/images/image-2.png)
- Trong đó:

  - x là cửa sổ trượt,
  - xi là số lần xuất hiện của i trong x
  - P là tỉ lệ (tức là |x_i |/|x| ).
  - Trong bài nghiên cứu này, các mẫu mã độc sẽ được đặt kích thước của cửa sổ trượt là 32x32 và cơ số là 10.

- Chuyển đổi entropy sang hệ màu RGB
  ![alt text](./docs/images/image.png)

  - ![alt text](./docs/images/image-1.png)

    <details>
    <summary>Code minh họa tính entropy ở file `entropy.py` </summary>
      
    ### Code minh họa `entropy.py`

- ```python
    import os
      import multiprocessing
      import lib.binvis as bv

      test_samples = os.listdir('./sample/test')
      malware_samples = os.listdir('./sample/IoT/')
      benign_samples = os.listdir('./sample/IoT_benign')
      cwd = os.getcwd()

      out_path = '.\\out'
      test_path = '.\\test'

      def calc_sample_entropy(sample):
      print('[+] Calculating entropy for {}'.format(sample)) # bv.binvis(cwd + '\\sample\\IoT\\' + sample, output_path=out_path)
      bv.binvis(cwd + '\\sample\\IoT_benign\\' + sample, output_path=out_path + '\\benign\\') # bv.binvis(cwd + '\\sample\\test\\' + sample, output_path=test_path)
      return

      def main(): # new_malware_samples = malware_samples.copy()
      new_benign_samples = benign_samples.copy()
      new_test_sample = test_samples.copy()
      print("[+] Benign sample size {}".format(len(new_benign_samples))) # for sample in new_malware_samples: # if os.path.isfile(out_path + sample + '.png'): # # print("[!] Sample {} already calculated skipping".format(sample)) # new_malware_samples.remove(sample)
      count = 0
      for sample in new_benign_samples:
      if os.path.isfile(out_path + '\\benign\\' + sample + '.png'): # print("[!] Sample {} already calculated skipping".format(sample))
      count += 1
      new_benign_samples.remove(sample)
      print("[!] Skipping {} samples".format(count)) # for sample in new_test_sample: # if os.path.isfile(test_path + sample + '.png'): # # print("[!] Sample {} already calculated skipping".format(sample)) # new_test_sample.remove(sample)

            # with multiprocessing.Pool(5) as p:
            #    p.map(calc_sample_entropy, new_benign_samples)

      if **name** == "**main**":
      main()
  ```

    </details>

### [**Feature Extraction**](#feature-extraction)

- Chuyển đổi dải màu sang hình ảnh
- ![alt text](./docs/images/image-3.png)
- parameter map = square, size (của ảnh) = 224, color = entropy.
- Áp dụng đường cong Hilbert để biểu diễn theo dạng hình ảnh của tệp nhị phân busybox
- ![alt text](./docs/images/image-4.png)

## [**MODEL MACHINE LEARNING**](#model-machine-learning)

### [**Build Model**](#build-model)

- Lớp Convolutional
- Lớp fully connected
- Lớp Pooling: có 2 lớp đặc trưng là lớp pooling cục bộ và lớp pooling toàn cục

> Note: Lưu ý: Cách chọn tham số cho CNN
> Số các convolution layer: càng nhiều các convolution layer thì performance càng được cải thiện. Sau khoảng 3 hoặc 4 layer, các tác động được giảm một cách đáng kể
> Filter size: thường filter theo size 5×5 hoặc 3×3
> Pooling size: thường là 2×2 hoặc 4×4 cho ảnh đầu vào lớn
> Cách cuối cùng là thực hiện nhiều lần việc train test để chọn ra được param tốt nhất.

### [**CNN Models Popular**](#cnn-models-popular)

• LeNet (1998)
• AlexNet (2012)
• OverFeat (2013)
• VGGNet (2014)
• GoogleNet (2014)
• ResNet (2015)

### [**Choose Model and Params for Model**](#choose-model-params)

- Chọn model này AlexNet (2012) vì ...

```python
from tensorflow import keras

def create_model(input_shape):
    model = keras.models.Sequential([

        # Alex Net (2012)
        keras.layers.Conv2D(filters=64, kernel_size=(1, 1), strides=(2, 2), input_shape=input_shape, activation='relu', padding='same'),
        keras.layers.MaxPool2D(pool_size=(2, 2)),

        keras.layers.Conv2D(filters=128, kernel_size=(1, 1), strides=(1, 1), activation='relu', padding='same'),
        keras.layers.MaxPool2D(pool_size=(2, 2)),

        keras.layers.Conv2D(filters=128, kernel_size=(1, 1), strides=(1, 1), activation='relu', padding='same'),

        keras.layers.Flatten(),  # 64*64*8
        keras.layers.Dense(1024, activation='relu'),
        keras.layers.Dropout(0.2),
        keras.layers.Dense(512, activation='relu'),
        keras.layers.Dropout(0.2),
        keras.layers.Dense(128, activation='relu'),
        keras.layers.Dropout(0.2),
        keras.layers.Dense(2, activation='softmax')
    ])

    return model
```

## [**EVALUATION AND RESULT**](#evaluation-result)

- Kết quả phát hiện mã độc IoT bằng hình ảnh entropy

| Phương pháp      | Các thuật toán | Phương pháp trích xuất đặc trưng | Độ chính xác (Accuracy %) |
| ---------------- | -------------- | -------------------------------- | ------------------------- |
| Hình ảnh entropy | CNN            | Entropy                          | 97.3%                     |

## [**CONCLUSION**](#conslution)

- Kết luận: Trong bài nghiên cứu này, Phương pháp chuyển tệp nhị phân sang hình ảnh bằng phương pháp entropy, nghiên cứu và phân tích các thành phần trong mạng CNN đạt hiệu quả.

## [**REFERENCE**](#reference)

- [1] Link bài báo khoa học ứng theo yêu cầu của thầy Minh Lịnh: [Lightweight IoT Malware Detection Solution Using CNN Classification](https://www.researchgate.net/publication/344639443_Lightweight_IoT_Malware_Detection_Solution_Using_CNN_Classification)

- [2] Code mẫu: [GitHub Repository](https://github.com/thangnguyenchien/iot-malware-detection-using-neural-network/blob/main/model.py)

> Note: Các khái niệm

- [3] TensorFlow: [Trang hướng dẫn của TensorFlow](https://www.tensorflow.org/tutorials/keras/classification)
- [4] Dense: [YouTube Video](https://www.youtube.com/watch?v=oJ1i2c1KxKk)
- [5] CNN là gì?: [Bài viết từ Vietnix](https://vietnix.vn/cnn-la-gi/#:~:text=qu%C3%A9t%20qua%20input.-,Relu%20layer,Sigmoid%2C%20Maxout%2C%20Leaky%2C%E2%80%A6)
- [6] Bài 6: Convolutional Neural Network: [Bài viết từ Nttuan8.com](https://nttuan8.com/bai-6-convolutional-neural-network/)
- [7] Thuật toán Convolutional Neural Network (CNN - Phần 2) - Python: [YouTube Video](https://www.youtube.com/watch?v=BJmAsX_jyj4&list=PL8ZSveYn9kVT0DcOXQKcnuhLlCZeG3a-k&index=2)
- [8] Blog - Deep learning: [Nttuan8.com](https://nttuan8.com/)
- [9] TensorFlow Document: [API Documentation](https://www.tensorflow.org/api_docs/python/tf/keras/Model)
- [10] Cross-Entropy: [Machine Learning Mastery](https://machinelearningmastery.com/loss-functions-in-tensorflow/)
- [11] Dropout: [Pham Duy Tung](https://www.phamduytung.com/blog/2019-05-05-deep-learning-dropout/#:~:text=Dropout%20l%C3%A0%20g%C3%AC%2C%20n%C3%B3%20c%C3%B3%20%C3%BD%20ngh%C4%A9a%20g%C3%AC%20trong%20m%E1%BA%A1ng%20neural%20network&text=Hi%E1%BB%83u%20%C4%91%C6%A1n%20gi%E1%BA%A3n%20l%C3%A0%2C%20trong,%C4%91%C6%B0%E1%BB%A3c%20l%E1%BB%B1a%20ch%E1%BB%8Dn%20ng%E1%BA%A7u%20nhi%C3%AAn)
- [12] Tại sao mạng tích chập lại hoạt động hiệu quả?: [Viblo](https://viblo.asia/p/tai-sao-mang-tich-chap-lai-hoat-dong-hieu-qua-jvEla076Zkw)
- [13] Convolution 2D: tf.keras.layers.Conv2D: [API Documentation](https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv2D)
- [14] Max Pooling 2D: MaxPool2D: [API Documentation](https://www.tensorflow.org/api_docs/python/tf/keras/layers/MaxPool2D)
- [15] Các layers quan trọng trong deep learning: [Blog Post](https://phamdinhkhanh.github.io/2019/12/02/DeepLearningLayer.html)
- [16] Lý do Dropout 0.5?: [Nghiên cứu NeurIPS](https://proceedings.neurips.cc/paper/2013/file/71f6278d140af599e06ad9bf1ba03cb0-Paper.pdf)
- [17] Cài đặt Library Keras, TensorFlow: [Hướng dẫn cài đặt](https://www.tensorflow.org/install)
- [18] Thiết lập GPU thay CPU cho TensorFlow: [Hướng dẫn cài đặt](https://www.tensorflow.org/install/gpu_plugins)
- [19] Tìm hiểu về class activation mapping - Tại sao các mạng thần kinh lại đưa ra quyết định như vậy?: [Viblo](https://viblo.asia/p/tim-hieu-ve-class-activation-maping-tai-sao-cac-mang-than-kinh-lai-dua-ra-quyet-dinh-nhu-vay-63vKjDXkl2R)
- [20] Understanding and Calculating the number of Parameters in Convolution Neural Networks (CNNs): [Blog Post](https://towardsdatascience.com/understanding-and-calculating-the-number-of-parameters-in-convolution-neural-networks-cnns-fc88790d530d)
- [21] How Do Convolutional Layers Work in Deep Learning Neural Networks?: [Blog Post](https://machinelearningmastery.com/convolutional-layers-for-deep-learning-neural-networks/)
- [22] Inception V4: [GitHub Repository](https://github.com/kentsommer/keras-inceptionV4/blob/ef1db6f09b6511779c05fab47d374741bc89b5ee/inception_v4.py#L242)
- ...
